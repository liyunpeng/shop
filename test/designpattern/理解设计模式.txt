模式是为了方便我们解决问题而总结出来的一套编码规则，
并不是我们不用设计模式代码的扩展性就一定差，选择使用模式还是要慎重，
大多数情况下还是要依靠需求的情景来考虑需不需要这种模式，
在决定使用之前一定要考虑好为什么要用这种模式。

---
单例模式：
考虑到并发安全， 所以用锁， 但锁的代价大， 为避免每次都上锁，用nil判断：
if m == nil{
        lock.Lock()
        defer lock.Unlock()
        if m == nil{
            m = &single{}
        }
}
以上在go 里简单的写法once.Do() , 保证了并发安全， 也保证了不会每次调用， 即保证效率

---
策略模式
策略模式就是将算法从业务程序里分离出来
策略模式定义：
一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化。

策略模式体现了对扩展开放，对修改关闭，即开闭原则
关闭原则指： 如果要增加一些规则，完全不用修改主业务流程，只需要增加几个策略就ok，
所有的设计模式都是要遵循针对接口编程， 策略模式也不列外

策略模式的核心就是将容易变动的代码从主逻辑中分离出来，
通过一个接口来规范它们的形式，
在主逻辑中将任务委托给策略。
这样做既减少了我们对主逻辑代码修改的可能性，也增加了系统的可扩展性。
一定要记得，我们的代码要往对扩展开发，对修改关闭这条设计原则上努力

---
工厂模式
优点：
1、一个调用者想创建一个对象，只要知道其名称就可以了。
2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
3、屏蔽产品的具体实现，调用者只关心产品的接口。

缺点：
每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，
在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

使用场景：
1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

注意事项：
作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。
有一点需要注意的地方就是复杂对象适合使用工厂模式，
而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。
如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

---
适配器模式：
适配器模式是用于当别人提供的对象或接口中的方法或者其它属性啥的和我们的重复了，
或者看的不顺眼。名字太长了记不住，而将其包装到一个对象中，
然后通过你感觉自己舒服的方式或者方法名字去间接的调用它。
一个简单的例子就是三角插座，我没有三角口，用一个转接器呗。

对象适配器：
将那个你看的不顺眼的对象的引用存在你的包装类对象内

---
桥接模式
桥接模式是为了通过一个公共接口来创建这个类的一个实例。
然而这个类是一个完全的由其它类组合而成的一个类。通过这个公有的接口类，
我们可以控制其中其它的类之间的组成，比如说我要创建一个animal，animal由sex、nam这两个类组成，
我可以通过animal而自由搭配，雌雄、其它动物名。
与其说是这样的组合模式，不如说，这是将一个结构拆散成不同的具体类型，然后通过这个结构传参创建。

---
责任链：
判断责任链， 代码中有sethandler, 就是责任链模式了。
广泛用于请求的处理， 不同的请求路由到不同的责任链中，
请求中指定的method,即指定责任链中具体是哪个责任处理者来处理。

责任链模式为请求创建了一个接收者对象的链。
处理请求的对象是一系列链条，或者一个集合。每个处理节点都保存有其他处理节点的引用。
接收到请求的时候，会判断该请求是否需要自己处理，
处理完毕传给下一个处理节点，有点像流水线作业。

优点：
降低耦合度。它将请求的发送者和接收者解耦。
简化了对象。使得对象不需要知道链的结构。
增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。
增加新的请求处理类很方便。
缺点：
不能保证请求一定被接收。
系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。
可能不容易观察运行时的特征，有碍于除错。

责任链log打印，方便理解：
D:\goworkspace\shop\test\designpattern>go test -v responsibilitychain_test.go
=== RUN   TestChainResponsibity
[Info] 2020/05/06 17:15:21 responsibilitychain_test.go:63: SetHandler用于本处理者设置责任的下一个处理者，这里下一个处理者的名
字= POST
[Info] 2020/05/06 17:15:21 responsibilitychain_test.go:66: 下个处理者可以有很多个，每个责任处理者都有自己的handlers集合, 表示
下一个处理者的集合， handlers= map[POST:0xc0000364a0]
[Info] 2020/05/06 17:15:21 responsibilitychain_test.go:127: 一个责任链可以接受很多请求，一个请求用一个键值对表示， key为请求
的url= login value= 0x5084c0
[Info] 2020/05/06 17:15:21 responsibilitychain_test.go:34: 请求中的methdo这里被当作责任链上责任者的名字来用， 这个责任者的名
字= POST
[Info] 2020/05/06 17:15:21 responsibilitychain_test.go:84: RootProcesser 处理者处理一个请求， 该请求为 &{POST login map[passw
ord:[222] username:[111]]}
[Info] 2020/05/06 17:15:21 responsibilitychain_test.go:85: RootProcesser 处理者处理方式时把请求交给责任链上的下一个处理者
[Info] 2020/05/06 17:15:21 responsibilitychain_test.go:108: PostProcesser处理者处理一个请求， 该请求为 &{POST login map[passw
ord:[222] username:[111]]}
[Info] 2020/05/06 17:15:21 responsibilitychain_test.go:109: PostProcesser处理者没有把请求转给下一个处理者，而是实实在在的为请
求做事情
111
222
PASS: TestChainResponsibity (0.02s)
PASS
ok      command-line-arguments  0.286s

----
外观模式：
Facade Pattern
外观模式其实就是把复杂的东西给封装，由统一的接口进行操作。这样可以简化用户的使用。

例子
如果要开一家饭馆，一个饭馆分为采购的，管仓库的，切菜的，炒菜的，吃菜的。
而采购的，管仓库的，切菜的，炒菜的，是厨房。吃菜的，是客户。
客户并不希望知道厨房工作的细节，只希望告诉厨房自己想吃什么就行了，
他不想告诉厨房要去买什么菜，怎么切，怎么炒。而巧的是，厨房也只希望给客户提供有限的选择即可，
具体工作的细节由自己控制就行。因此厨房和客户之间只隔着一个菜单和服务员。

---
过滤器
这种模式允许开发人员使用不同的标准来过滤一组对象，
通过逻辑运算以解偶的方式把它们连接起来。这种类型的设计模式属于结构型模式