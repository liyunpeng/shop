模式是为了方便我们解决问题而总结出来的一套编码规则，
并不是我们不用设计模式代码的扩展性就一定差，选择使用模式还是要慎重，
大多数情况下还是要依靠需求的情景来考虑需不需要这种模式，
在决定使用之前一定要考虑好为什么要用这种模式。

---
单例模式：
考虑到并发安全， 所以用锁， 但锁的代价大， 为避免每次都上锁，用nil判断：
if m == nil{
        lock.Lock()
        defer lock.Unlock()
        if m == nil{
            m = &single{}
        }
}
以上在go 里简单的写法once.Do() , 保证了并发安全， 也保证了不会每次调用， 即保证效率

---
策略模式
策略模式就是将算法从业务程序里分离出来
策略模式定义：
一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化。

策略模式体现了对扩展开放，对修改关闭，即开闭原则
关闭原则指： 如果要增加一些规则，完全不用修改主业务流程，只需要增加几个策略就ok，
所有的设计模式都是要遵循针对接口编程， 策略模式也不列外

策略模式的核心就是将容易变动的代码从主逻辑中分离出来，
通过一个接口来规范它们的形式，
在主逻辑中将任务委托给策略。
这样做既减少了我们对主逻辑代码修改的可能性，也增加了系统的可扩展性。
一定要记得，我们的代码要往对扩展开发，对修改关闭这条设计原则上努力

---

优点：
1、一个调用者想创建一个对象，只要知道其名称就可以了。
2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
3、屏蔽产品的具体实现，调用者只关心产品的接口。

缺点：
每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，
在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

使用场景：
1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

注意事项：
作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。
有一点需要注意的地方就是复杂对象适合使用工厂模式，
而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。
如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。