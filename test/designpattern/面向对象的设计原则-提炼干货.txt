制定架构，编写代码，阅读代码， 带着这些原则和设计模式看。
考量其扩展型， 灵活性，可插入性
一 开-闭原则
1. 在设计一个模块的时候，应当使这个模块可以在抽象层不被修改的前提下被扩展。
最重要的抽象层模块一定不能再修改，
如B2c， 有base， dev, pam等基础应用，
这些基础应用规定了很多模块的抽象层， 不能被修改。
2. 对可变性的封装不应该散落在代码的很多角落，而应当被封装到一个对象里面，
比如配置对象， 因为配置数据是可变的， 所有的配置数据都封装在配置对象里。
工厂模式把可能新增加的实体类，隔离到工厂里面。
策略模式把可能新增的算法类， 隔离到策略里面。

二 里氏代换原则
从抽象化导出具体化过程。
具体化可以给出不同的版本，每一个版本都给出不同的实现。
如
session的多种provider，
go-micro的regtistry可以用etcd, consul,
gorm 用同一个Open函数可以打开不同种类的数据库：
DB, err = gorm.Open("mysql",  "root:root@tcp(192.168.0.223:3306)/gotest?charset=utf8")

session, micro, gorm对他们的使用上没区别， 即系统觉察不出不同实现的差异

三 依赖倒转原则
下依赖于上，细节依赖于抽象
如session 规定了provider的接口

四 和组合/聚合复用
尽量用组合，不用继承。 因为继承，
父类的任何改变， 都会影响到所有子类。
父类有一些子类不需要， 但子类无法去除这些。
这两点造成继承有好大的耦合性。
尽量用接口，组合的方式封装， 不用继承封装。
如 go 的封装就没有继承

五 迪米特法则
即最少知识原则， 一个软件实体应当与尽可能少的其他实体发生相互作用。
函数的高内聚特性， 即函数只作一件事情。不能把这个事情之外的其他动作里面。
这个列子遍布在每个函数

六 接口隔离
接口里的函数要宜少，不宜多。
不为接口的实现者增加不必要的负担。
（即接口小原则）原则所保证；
每个模块相对于其他模块独立存在，并只保持与其他模块尽可能少的通信
