---
直接srv方式
对外提供restful.api 服务的是通过 api 框架或原生写法,
直接调用的是 srv内部调用, 是客户端去访问 服务端

直接 /rpc 调用的时候会绕过 restful.api, 直接调用srv (http请求 会自动转成 rpc调用)
（但是 micro api 网关是必须启动的，网关也可配置）

---
api方式
API网关一般作用：
封装了内部系统架构
并且提供了每个客户端定制的
API、身份验证、监控、负载均衡、缓存、数据通信协议转换、统一维护流量路由表

---
添加插件
加一些其他功能， 比如鉴权则需要实现Micro Api的插件，可以参考项目中的实现

---
客户端的请求：
Micro Api通过接收前端HTTP请求，将请求转换之后发送到内部服务，

---
服务间的请求：
对于服务间的请求，A服务可以直接使用go语言的gRPC客户端调用B服务的接口。
相比在使用Restful方式完成服务之间的相互访问，gRPC能提供更好的性能，更低的延迟，
并且生来适合与分布式系统。

---
用户身份鉴定：
功能是除了登录功能的每一个API都会调用的功能。统一在api 网关处理。
对于容器化与无状态服务，可以使用JWT进行身份验证，
以下是一个例子，从Authorization中解析出用户信息然后传递给网关后的服务。

---
服务端：
Server包是使用编写服务的构建包，可以命名服务，注册请求处理器，增加中间件等等

服务熔断：当服务A调用服务B的请求满足一定的规则，
比如10秒内请求数达到20个，并且有一半以上的请求失败了，
此时我们通过切断对服务B的调用来保护系统的整体响应，这种操作即为服务熔断。

服务降级：在服务B被熔断之后，服务A不会真正地调用服务B。
取而代之的是，我们在服务A中定义一个服务降级逻辑（通常是一个fallback接口），
此时服务A会直接调用服务降级逻辑快速获取返回结果。

---
客户端：
客户端提供接口来创建向服务端的请求。与服务端类似，
它构建在其它包之上，它提供独立的接口，
通过注册中心来基于名称发现服务，基于选择器（selector）来负载均衡，
使用transport、broker处理同步、异步消息。

---
微服务注册与发现：
服务的注册发现对于微服务来说是一个非常重要的环节，
在单一架构应用中，service 之间的互相调用，
通过一个固定的 host 和 port 来发起 REST 或者 RPC 来调用，
但是在微服务架构中，各个服务往往是动态变化的，
所以需要一个服务发现机制来发送客户端的请求到动态的 service 实例中去。

---
go-micro组成部分：
broker负责消息
Codec负责编码
Registry负责注册发现
Selector负责负载均衡
Transport负责接收请求与响应。

在分布式系统中，有服务发现，负载均衡、同步/异步通信、消息编码等,
Go-Micro为我们抽象出了这些细节，这样我们就可以使用Go-Micro更快的进行分布式开发

---
golang学习需要转换的思维：
数据处理和类型转换以及 类型定义
同一份代码在多个地方部署，最后注册成同一个服务名称，不同的ip地址（也可以相同）或端口号
Cli 命令行的方式调用不需要运行 micro api 网关，
不需要 启动 go.micro.api.auth 服务。是直接调用 go.micro.srv.auth 服务
